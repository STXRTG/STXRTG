require('dotenv').config();const express = require('express');const sqlite3 = require('sqlite3').verbose();const cors = require('cors');const rateLimit = require('express-rate-limit');const fs = require('fs');const path = require('path');const app = express();const PORT = process.env.PORT || 3000;app.use(cors());app.use(express.json());app.use(express.static(path.join(__dirname, 'public'))); const dbDir = path.join(__dirname, 'data');if (!fs.existsSync(dbDir)) {    fs.mkdirSync(dbDir);}const db = new sqlite3.Database(path.join(dbDir, 'analytics.db'));db.serialize(() => {    db.run(`CREATE TABLE IF NOT EXISTS users (        id INTEGER PRIMARY KEY AUTOINCREMENT,        hashed_uuid TEXT UNIQUE,        first_seen DATETIME DEFAULT CURRENT_TIMESTAMP,        last_seen DATETIME DEFAULT CURRENT_TIMESTAMP    )`);    db.run(`CREATE TABLE IF NOT EXISTS mod_usage (        user_id INTEGER,        mod_name TEXT,        last_used DATETIME DEFAULT CURRENT_TIMESTAMP,        PRIMARY KEY (user_id, mod_name),        FOREIGN KEY(user_id) REFERENCES users(id)    )`);});const trackerLimiter = rateLimit({    windowMs: 15 * 60 * 1000,     max: 100,     message: { error: 'Too many requests, please try again later.' }});app.post('/api/track', trackerLimiter, (req, res) => {    const { hashed_uuid, mod_name } = req.body;    if (!hashed_uuid || !mod_name) {        return res.status(400).json({ error: 'Missing required fields' });    }    db.run(`        INSERT INTO users (hashed_uuid)         VALUES (?)        ON CONFLICT(hashed_uuid) DO UPDATE SET last_seen = CURRENT_TIMESTAMP    `, [hashed_uuid], function (err) {        if (err) {            console.error('Error recording user:', err.message);            return res.status(500).json({ error: 'Internal server error' });        }        db.get('SELECT id FROM users WHERE hashed_uuid = ?', [hashed_uuid], (err, row) => {            if (err || !row) return res.status(500).json({ error: 'Database error' });            const userId = row.id;            db.run(`                INSERT INTO mod_usage (user_id, mod_name)                 VALUES (?, ?)                ON CONFLICT(user_id, mod_name) DO UPDATE SET last_used = CURRENT_TIMESTAMP            `, [userId, mod_name], (err) => {                if (err) {                    console.error('Error recording mod usage:', err.message);                    return res.status(500).json({ error: 'Internal server error' });                }                res.status(200).json({ success: true });            });        });    });});app.post('/api/login', (req, res) => {    const { password } = req.body;    const realPassword = process.env.ADMIN_PASSWORD;    if (!realPassword) {        return res.status(500).json({ success: false, error: 'Admin password not configured on server' });    }    if (password === realPassword) {        res.json({ success: true, token: 'admin_session_valid' });    } else {        res.status(401).json({ success: false, error: 'Invalid password' });    }});app.get('/api/stats', (req, res) => {    const stats = {        total_unique_players: 0,        live_players: 0,        daily_active_users: 0,        dau_trend_pct: 0,        total_pings_24h: 0,        mods: {}     };    db.get('SELECT COUNT(*) as count FROM users', (err, row) => {        if (err) return res.status(500).json({ error: 'Database error' });        stats.total_unique_players = row.count;        db.get(`SELECT COUNT(*) as count FROM users WHERE last_seen >= datetime('now', '-24 hour')`, (err, dauRow) => {            if (err) return res.status(500).json({ error: 'Database error' });            stats.daily_active_users = dauRow.count;            db.get(`SELECT COUNT(*) as count FROM users WHERE last_seen >= datetime('now', '-48 hour') AND last_seen < datetime('now', '-24 hour')`, (err, prevDauRow) => {                if (err) return res.status(500).json({ error: 'Database error' });                let prev = prevDauRow.count;                if (prev === 0) {                    stats.dau_trend_pct = stats.daily_active_users > 0 ? 100 : 0;                } else {                    stats.dau_trend_pct = Math.round(((stats.daily_active_users - prev) / prev) * 100);                }                db.get(`SELECT COUNT(*) as count FROM users WHERE last_seen >= datetime('now', '-5 minute')`, (err, liveRow) => {                    if (err) return res.status(500).json({ error: 'Database error' });                    stats.live_players = liveRow.count;                    db.all(`                    SELECT                         mod_name,                         COUNT(*) as total_users,                        SUM(CASE WHEN last_used >= datetime('now', '-24 hour') THEN 1 ELSE 0 END) as active_24h                    FROM mod_usage                     GROUP BY mod_name                `, (err, rows) => {                        if (err) return res.status(500).json({ error: 'Database error' });                        let total24hPings = 0;                        rows.forEach(r => {                            stats.mods[r.mod_name] = {                                total: r.total_users,                                active_24h: r.active_24h || 0                            };                            total24hPings += (r.active_24h || 0);                        });                        stats.total_pings_24h = total24hPings;                        res.json(stats);                    });                });            });        });    });});app.listen(PORT, () => {    console.log(`Analytics API Server running on port ${PORT}`);    const bot = require('./bot');    bot.startBot();});module.exports = {    db};